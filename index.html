<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NSS Golf Community Events</title>

  <style>
    :root{
      --bg1:#061C3B; --bg2:#04142E; --bg3:#020B18;

      --card-bg: rgba(15,23,42,1);
      --card-shadow: 0 32px 32px rgba(0,0,0,0.65);

      --text: #e9eef8;
      --title: #c7d7ff;
      --muted: #9ca3c7;

      --border-lite: rgba(148,163,184,0.20);
      --btn-bg: rgba(255,255,255,0.06);
      --btn-bg-hover: rgba(255,255,255,0.10);
      --btn-border: rgba(255,255,255,0.15);
      --btn-border-hover: rgba(255,255,255,0.28);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      background: linear-gradient(to bottom, var(--bg1), var(--bg2), var(--bg3));
    }

    /* Topbar (matches your site vibe) */
    .topbar{
      position: sticky; top:0; z-index:10;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(3,18,42,.70);
      backdrop-filter: blur(10px);
    }
    .topbar-inner{
      max-width:1100px;
      margin:0 auto;
      padding: 14px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{display:flex; gap:12px; align-items:center;}
    .home-badge{
      width:40px; height:40px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.05);
      display:grid; place-items:center;
      overflow:hidden;
      user-select:none;
    }
    .home-badge img{
      width:70%;
      height:70%;
      object-fit: contain;
      display:block;
      pointer-events:none;
    }

    .kicker{
      font-size:11px;
      letter-spacing:.25em;
      text-transform:uppercase;
      color: rgba(255,255,255,.65);
      font-weight:900;
    }

    .container{
      max-width:1100px;
      margin:0 auto;
      padding: 28px 18px 56px;
      display:flex;
      justify-content:center;
    }

    .card{
      width: min(820px, 100%);
      background: var(--card-bg);
      border-radius: 20px;
      padding: 22px 20px;
      box-shadow: var(--card-shadow);
      border: 1px solid rgba(255,255,255,0.10);
    }

    .headline{
      font-size: 22px;
      font-weight: 950;
      color: var(--title);
      letter-spacing: .035em;
      text-transform: uppercase;
      margin: 0 0 10px 0;
    }

    .copy{
      margin: 0;
      color: rgba(233,238,248,0.92);
      font-size: 15px;
      line-height: 1.55;
      font-weight: 700;
    }

    .actions{
      margin-top: 18px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      padding-top: 16px;
      border-top: 1px solid var(--border-lite);
    }

    .video-section{
      margin-top: 22px;
      padding-top: 18px;
      border-top: 1px solid var(--border-lite);
    }

    .video-header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .section-title{
      margin: 0;
      font-size: 18px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--title);
    }

    .video-subtext{
      margin: 6px 0 14px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
    }

    .sort-control{
      display:flex;
      align-items:center;
      gap: 8px;
      font-size: 12px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: rgba(255,255,255,0.7);
    }

    .sort-control select{
      background: var(--btn-bg);
      border: 1px solid var(--btn-border);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .video-status{
      font-size: 13px;
      color: rgba(233,238,248,0.7);
      margin-bottom: 12px;
      font-weight: 600;
      white-space: pre-wrap;
    }

    .video-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .video-card{
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding: 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(6,24,46,0.7);
    }

    .video-thumb{
      width:100%;
      aspect-ratio: 16 / 9;
      border-radius: 12px;
      object-fit: cover;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .video-title{
      font-size: 14px;
      font-weight: 800;
      margin: 0;
      color: var(--text);
    }

    .video-meta{
      font-size: 12px;
      color: rgba(233,238,248,0.7);
      display:flex;
      flex-direction:column;
      gap: 4px;
      font-weight: 600;
    }

    .channel-card{
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding: 16px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(6,24,46,0.7);
    }

    .channel-avatar{
      width: 56px;
      height: 56px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .channel-name{
      font-size: 15px;
      font-weight: 900;
      margin: 0;
      color: var(--text);
    }

    .channel-meta{
      font-size: 12px;
      color: rgba(233,238,248,0.7);
      display:flex;
      flex-direction:column;
      gap: 4px;
      font-weight: 600;
    }

    .btn{
      appearance:none;
      -webkit-appearance:none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: rgba(255,255,255,0.92);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 950;
      text-transform: uppercase;
      letter-spacing: .10em;
      font-size: 12px;
      cursor:pointer;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      line-height: 1;
    }
    .btn:hover{
      background: var(--btn-bg-hover);
      border-color: var(--btn-border-hover);
    }

    .footer{
      margin-top: 18px;
      text-align:center;
      font-size:12px;
      color: rgba(233,238,248,0.55);
    }

    @media (max-width: 760px){
      .container{ padding: 20px 12px 44px; }
      .topbar-inner{ padding: 12px 12px; }
      .headline{ font-size: 18px; }
      .card{ padding: 18px 14px; border-radius: 18px; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="home-badge" aria-hidden="true">
          <img src="/logos/golf.png" alt="Home" loading="eager" decoding="async" />
        </div>
        <div>
          <div class="kicker">NSS Golf Community</div>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="card">
      <h1 class="headline">Welcome</h1>
      <p class="copy">
        Welcome to the NSS Golf Community Events Page! Select an event to view results and leaderboards.
      </p>

      <div class="actions">
        <a class="btn" href="https://teamupdiscord.com/leaderboard/client/DISCORD%7C1069003073311211601/leaderboard/Season_11/rating_type/player_global_all/format/global" target="_blank" rel="noopener noreferrer" aria-label="Open Ranked League Leaderboard">
          Ranked League
        </a>

        <a class="btn" href="/proleague" aria-label="Go to Pro League">
          Pro League
        </a>
      </div>

      <section class="video-section" aria-labelledby="video-section-title">
        <div class="video-header">
          <h2 class="section-title" id="video-section-title">Last Month's Channel Videos</h2>
          <label class="sort-control" for="video-sort">
            Sort
            <select id="video-sort">
              <option value="recent">Most Recent</option>
              <option value="views">Most Viewed</option>
              <option value="channels">Channels</option>
            </select>
          </label>
        </div>
        <p class="video-subtext">Showing videos uploaded in the previous month from the NSS Golf community channels.</p>
        <div class="video-status" id="video-status">Loading videos…</div>
        <div class="video-grid" id="video-grid"></div>
      </section>

      <div class="footer">NSS Golf Community Events</div>
    </div>
  </div>

  <script>
    // === CONFIG ===
    // NOTE: This assumes your Cloudflare Worker is updated to support:
    //   GET /proxy?url=<encoded>
    // and returns CORS headers.
    const WORKER_URL = "https://small-mud-2771.nextweekmedia.workers.dev/";
    const SHEET_ID = "1VGouXR7onYOeu7T4oiFSId-TtdJMFS0Nc3CYcjYM6-k";
    const SHEET_NAME = "Channels";

    // === ELEMENTS ===
    const statusEl = document.getElementById("video-status");
    const gridEl = document.getElementById("video-grid");
    const sortEl = document.getElementById("video-sort");

    const dateFormatter = new Intl.DateTimeFormat("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
    });

    // === STATE ===
    let STATE = {
      channels: [],
      videos: [],
      viewsReady: false,
      lastStatusHint: "",
    };

    // === HELPERS ===
    function normalizeValues(resp){
      if(!resp) return [];
      if(Array.isArray(resp)) return resp;
      if(Array.isArray(resp.values)) return resp.values;
      if(Array.isArray(resp.data?.values)) return resp.data.values;
      if(Array.isArray(resp.result?.values)) return resp.result.values;
      return [];
    }

    async function fetchRange(a1){
      const range = `'${SHEET_NAME}'!${a1}`;
      const payload = { sheetId: SHEET_ID, range };

      // Prefer POST (you already have this pattern)
      try{
        const r = await fetch(WORKER_URL, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify(payload),
        });
        if(r.ok) return normalizeValues(await r.json());
      }catch(e){}

      // Fallback GET
      const u = new URL(WORKER_URL);
      u.searchParams.set("sheetId", SHEET_ID);
      u.searchParams.set("range", range);
      const r2 = await fetch(u.toString());
      if(!r2.ok){
        const text = await r2.text().catch(()=> "");
        throw new Error(`Worker request failed (${r2.status}). ${text}`.trim());
      }
      return normalizeValues(await r2.json());
    }

    function getPreviousMonthWindow(){
      const now = new Date();
      const start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      const end = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
      return { start, end };
    }

    function workerProxyUrl(targetUrl){
      const base = WORKER_URL.endsWith("/") ? WORKER_URL : (WORKER_URL + "/");
      return `${base}proxy?url=${encodeURIComponent(targetUrl)}`;
    }

    async function fetchWithTimeout(url, { timeoutMs = 12000, ...opts } = {}){
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), timeoutMs);
      try{
        return await fetch(url, { ...opts, signal: controller.signal });
      }finally{
        clearTimeout(t);
      }
    }

    async function fetchText(url){
      const proxied = workerProxyUrl(url);
      const res = await fetchWithTimeout(proxied, { timeoutMs: 15000 });
      if(!res.ok){
        const text = await res.text().catch(()=> "");
        throw new Error(`Proxy fetch failed (${res.status}). ${text}`.trim());
      }
      return res.text();
    }

    function stripTrailingSlash(value){
      return value.endsWith("/") ? value.slice(0, -1) : value;
    }

    function parseChannelUrl(entry){
      const raw = String(entry ?? "").trim();
      if(!raw) return null;
      try{
        const url = new URL(raw);
        const host = url.hostname.replace(/^www\./, "");
        if(host !== "youtube.com" && host !== "m.youtube.com" && host !== "youtu.be"){
          return null;
        }
        return stripTrailingSlash(url.href);
      }catch(error){
        return null;
      }
    }

    function parseChannelEntry(entry){
      const raw = String(entry ?? "").trim();
      if(!raw) return null;

      // Allow storing channel IDs directly in the sheet (recommended):
      // UCxxxxxxxxxxxxxxxxxxxxxx
      if(/^UC[a-zA-Z0-9_-]{20,}$/.test(raw)){
        return {
          url: `https://www.youtube.com/channel/${raw}`,
          id: raw,
          raw,
        };
      }

      const url = parseChannelUrl(raw);
      if(!url) return null;

      return { url, id: null, raw };
    }

    function extractChannelIdFromHtml(html){
      // YouTube markup varies; try several common keys.
      return (
        html.match(/"channelId":"(UC[^"]+)"/)?.[1] ||
        html.match(/"externalId":"(UC[^"]+)"/)?.[1] ||
        html.match(/"browseId":"(UC[^"]+)"/)?.[1] ||
        null
      );
    }

    function parseSubscriberCount(text){
      if(!text) return null;
      const cleaned = String(text).replace(/,/g, "").trim();
      // Matches "1.23M", "1.23 M", "123K", etc.
      const match = cleaned.match(/([\d.]+)\s*([KMB])?/i);
      if(!match) return null;
      const value = Number(match[1]);
      if(!Number.isFinite(value)) return null;
      const suffix = (match[2] || "").toUpperCase();
      const multipliers = { K: 1e3, M: 1e6, B: 1e9 };
      return Math.round(value * (multipliers[suffix] || 1));
    }

    function formatSubscribers(value){
      if(!Number.isFinite(value)) return "Subscribers: —";
      return `Subscribers: ${value.toLocaleString("en-US")}`;
    }

    function extractChannelStats(html){
      // More consistent on YouTube than <meta name="title">
      const name =
        html.match(/<meta property="og:title" content="([^"]+)"/i)?.[1] ||
        html.match(/<meta name="title" content="([^"]+)"/i)?.[1] ||
        null;

      const avatar =
        html.match(/<meta property="og:image" content="([^"]+)"/i)?.[1] ||
        "";

      // IMPORTANT: These patterns are NOT double-escaped now (we're matching raw HTML text).
      const subscriberText =
        html.match(/"subscriberCountText":\{"simpleText":"([^"]+)"/)?.[1] ||
        html.match(/"subscriberCountText":\{"runs":\[\{"text":"([^"]+)"/)?.[1] ||
        "";

      const subscribers = parseSubscriberCount(subscriberText);
      return { name, avatar, subscribers };
    }

    async function fetchChannelStats(channelUrl){
      try{
        const html = await fetchText(channelUrl);
        return extractChannelStats(html);
      }catch(error){
        console.warn("Channel stats fetch failed.", error);
        return { name: null, avatar: "", subscribers: null };
      }
    }

    async function resolveChannelId(channelUrl){
      try{
        const url = new URL(channelUrl);

        // Direct channel URL
        if(url.pathname.startsWith("/channel/")){
          const maybe = url.pathname.split("/")[2] || null;
          if(maybe && maybe.startsWith("UC")) return maybe;
        }

        // For @handles, /c/, /user/, etc, scrape and extract
        const html = await fetchText(url.href);
        return extractChannelIdFromHtml(html);
      }catch(error){
        console.warn("Channel lookup failed.", error);
        return null;
      }
    }

    function parseFeed(xmlText){
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, "application/xml");
      const entries = Array.from(doc.getElementsByTagName("entry"));
      return entries.map(entry => {
        const id = entry.getElementsByTagName("yt:videoId")[0]?.textContent?.trim();
        const title = entry.getElementsByTagName("title")[0]?.textContent?.trim();
        const published = entry.getElementsByTagName("published")[0]?.textContent?.trim();
        const channel = entry.getElementsByTagName("name")[0]?.textContent?.trim();
        const thumbnail = entry.getElementsByTagName("media:thumbnail")[0]?.getAttribute("url");

        // Many YouTube feeds do NOT include view stats; keep a default of null so UI can reflect "—"
        const viewsAttr = entry.getElementsByTagName("media:statistics")[0]?.getAttribute("views");
        const views = viewsAttr ? Number(viewsAttr) : null;

        return {
          id,
          title,
          channel,
          publishedAt: published ? new Date(published) : null,
          thumbnail,
          views: Number.isFinite(views) ? views : null,
        };
      }).filter(item => item.id);
    }

    async function fetchChannelFeed(channelId){
      try{
        const feedUrl = `https://www.youtube.com/feeds/videos.xml?channel_id=${channelId}`;
        const xmlText = await fetchText(feedUrl);
        return parseFeed(xmlText);
      }catch(error){
        console.warn("Channel feed fetch failed.", error);
        return [];
      }
    }

    function formatViews(value){
      const views = Number(value);
      if(!Number.isFinite(views)) return "Views: —";
      return `Views: ${views.toLocaleString("en-US")}`;
    }

    function buildVideoModel(item){
      const videoId = item?.id;
      if(!videoId) return null;
      return {
        id: videoId,
        title: item.title || "Untitled video",
        channel: item.channel || "Unknown channel",
        publishedAt: item.publishedAt || null,
        thumbnail: item.thumbnail || "",
        url: `https://www.youtube.com/watch?v=${videoId}`,
        views: Number.isFinite(item.views) ? item.views : null,
      };
    }

    function renderVideos(list){
      gridEl.innerHTML = "";
      if(!list.length){
        statusEl.textContent = "No videos were found for the previous month.";
        return;
      }

      const viewsMissing = list.every(v => !Number.isFinite(v.views));
      const hint = viewsMissing
        ? "\nNote: View counts may show as “—” unless the proxy can read them."
        : "";

      statusEl.textContent = `Showing ${list.length} video${list.length === 1 ? "" : "s"}.${hint}`;

      const frag = document.createDocumentFragment();
      for(const video of list){
        const card = document.createElement("article");
        card.className = "video-card";

        const link = document.createElement("a");
        link.href = video.url;
        link.target = "_blank";
        link.rel = "noopener noreferrer";

        const img = document.createElement("img");
        img.className = "video-thumb";
        img.src = video.thumbnail;
        img.alt = video.title;
        img.loading = "lazy";

        link.appendChild(img);

        const title = document.createElement("p");
        title.className = "video-title";
        title.textContent = video.title;

        const meta = document.createElement("div");
        meta.className = "video-meta";

        const channel = document.createElement("span");
        channel.textContent = video.channel;

        const published = document.createElement("span");
        published.textContent = video.publishedAt
          ? `Published: ${dateFormatter.format(video.publishedAt)}`
          : "Published: —";

        const views = document.createElement("span");
        views.textContent = formatViews(video.views);

        meta.append(channel, published, views);
        card.append(link, title, meta);
        frag.appendChild(card);
      }
      gridEl.appendChild(frag);
    }

    function renderChannels(list){
      gridEl.innerHTML = "";
      if(!list.length){
        statusEl.textContent = "No channels were found.";
        return;
      }
      statusEl.textContent = `Showing ${list.length} channel${list.length === 1 ? "" : "s"}.`;
      const frag = document.createDocumentFragment();
      for(const channel of list){
        const card = document.createElement("article");
        card.className = "channel-card";

        const link = document.createElement("a");
        link.href = channel.url;
        link.target = "_blank";
        link.rel = "noopener noreferrer";

        const avatar = document.createElement("img");
        avatar.className = "channel-avatar";
        avatar.src = channel.avatar || "";
        avatar.alt = channel.name || "Channel avatar";
        avatar.loading = "lazy";

        link.appendChild(avatar);

        const name = document.createElement("p");
        name.className = "channel-name";
        name.textContent = channel.name || channel.url;

        const meta = document.createElement("div");
        meta.className = "channel-meta";

        const subscribers = document.createElement("span");
        subscribers.textContent = formatSubscribers(channel.subscribers);

        const preview = document.createElement("span");
        preview.textContent = `Preview videos: ${channel.previewCount || 0}`;

        const latest = document.createElement("span");
        latest.textContent = channel.latest ? `Latest: ${dateFormatter.format(channel.latest)}` : "Latest: —";

        meta.append(subscribers, preview, latest);
        card.append(link, name, meta);
        frag.appendChild(card);
      }
      gridEl.appendChild(frag);
    }

    function sortVideos(list, mode){
      const sorted = [...list];
      if(mode === "views"){
        sorted.sort((a, b) => (Number(b.views) || 0) - (Number(a.views) || 0));
      }else{
        sorted.sort((a, b) => (b.publishedAt?.getTime() || 0) - (a.publishedAt?.getTime() || 0));
      }
      return sorted;
    }

    function sortChannels(list){
      return [...list].sort((a, b) => (Number(b.subscribers) || 0) - (Number(a.subscribers) || 0));
    }

    async function runWithConcurrency(items, limit, worker){
      const results = new Array(items.length);
      let idx = 0;

      async function runner(){
        while(true){
          const current = idx++;
          if(current >= items.length) return;
          results[current] = await worker(items[current], current);
        }
      }

      const runners = Array.from({ length: Math.max(1, Math.min(limit, items.length)) }, () => runner());
      await Promise.all(runners);
      return results;
    }

    // Best-effort view count enrichment (no API key).
    // This scrapes the watch page JSON and can break if YouTube changes markup.
    function extractViewCountFromWatchHtml(html){
      // Common patterns seen in watch pages / embedded JSON
      const m1 = html.match(/"viewCount":"(\d+)"/);
      if(m1) return Number(m1[1]);

      const m2 = html.match(/"viewCountText":\{"simpleText":"([\d,]+)\s+views"/);
      if(m2) return Number(m2[1].replace(/,/g, ""));

      const m3 = html.match(/"viewCountText":\{"runs":\[\{"text":"([\d,]+)"/);
      if(m3) return Number(m3[1].replace(/,/g, ""));

      return null;
    }

    async function enrichViewsIfNeeded(videos){
      // If ANY already have views, assume okay.
      if(videos.some(v => Number.isFinite(v.views))) return videos;

      statusEl.textContent = "Loading view counts for sorting…";
      const toFetch = videos.slice(0); // all videos

      await runWithConcurrency(toFetch, 4, async (video) => {
        try{
          const html = await fetchText(video.url);
          const views = extractViewCountFromWatchHtml(html);
          if(Number.isFinite(views)) video.views = views;
        }catch(e){
          // leave null
        }
      });

      return videos;
    }

    function renderFromState(){
      const mode = sortEl.value;

      if(mode === "channels"){
        renderChannels(sortChannels(STATE.channels));
        return;
      }

      let list = STATE.videos;
      list = sortVideos(list, mode);
      renderVideos(list);
    }

    async function loadData(){
      try{
        statusEl.textContent = "Loading channel list…";
        gridEl.innerHTML = "";

        const values = await fetchRange("A:A");
        const rows = values.map(row => row?.[0]).filter(Boolean);
        const trimmed = rows.map(entry => String(entry).trim()).filter(Boolean);
        const entries = trimmed.filter((entry, index) => !(index === 0 && entry.toLowerCase() === "channels"));

        if(!entries.length){
          statusEl.textContent = "No channels found in the sheet.";
          return;
        }

        const parsedEntries = entries.map(parseChannelEntry).filter(Boolean);
        if(!parsedEntries.length){
          statusEl.textContent = "No valid YouTube URLs or channel IDs were found.";
          return;
        }

        statusEl.textContent = "Resolving channel details…";

        // Resolve IDs + stats concurrently (faster, avoids one channel stalling all)
        const channelEntries = await runWithConcurrency(parsedEntries, 4, async (entry) => {
          const id = entry.id || await resolveChannelId(entry.url);
          const stats = await fetchChannelStats(entry.url);
          return {
            url: entry.url,
            id,
            name: stats.name || entry.url,
            avatar: stats.avatar,
            subscribers: stats.subscribers,
            previewCount: 0,
            latest: null,
          };
        });

        const validChannelEntries = channelEntries.filter(Boolean);
        const channelIds = validChannelEntries.filter(ch => ch.id).map(ch => ch.id);

        // If no IDs were found, video feeds cannot be loaded
        if(!channelIds.length){
          statusEl.textContent =
            "No valid channel IDs were found.\n" +
            "Fix: Put channel IDs (UC...) directly into the sheet OR ensure your Worker proxy can fetch YouTube pages.";
          STATE.channels = sortChannels(validChannelEntries);
          STATE.videos = [];
          renderFromState();
          return;
        }

        const { start, end } = getPreviousMonthWindow();
        const videos = [];

        // Load feeds (concurrently, but not too aggressively)
        await runWithConcurrency(validChannelEntries, 3, async (ch) => {
          if(!ch.id) return;

          try{
            const items = await fetchChannelFeed(ch.id);
            ch.previewCount = items.length;
            ch.latest = items
              .map(item => item.publishedAt)
              .filter(Boolean)
              .sort((a, b) => b - a)[0] || null;

            for(const item of items){
              const model = buildVideoModel(item);
              if(!model?.publishedAt) continue;
              if(model.publishedAt >= start && model.publishedAt <= end){
                videos.push(model);
              }
            }
          }catch(e){}
        });

        STATE.channels = validChannelEntries;
        STATE.videos = videos;
        STATE.viewsReady = false;

        if(!STATE.videos.length && sortEl.value !== "channels"){
          statusEl.textContent = "No videos were published last month.";
          gridEl.innerHTML = "";
          return;
        }

        renderFromState();
      }catch(error){
        statusEl.textContent = `Unable to load videos: ${error?.message || "Unknown error"}`;
        console.error(error);
      }
    }

    // One listener only (avoid duplicated handlers)
    sortEl.addEventListener("change", async () => {
      if(sortEl.value === "views"){
        // Best effort: fetch view counts only when needed for sorting
        if(!STATE.viewsReady){
          await enrichViewsIfNeeded(STATE.videos);
          STATE.viewsReady = true;
        }
      }
      renderFromState();
    });

    loadData();
  </script>
</body>
</html>
