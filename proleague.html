<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shotgun Pro League - Season 6</title>
    <style>
      :root{
        --bg1:#061C3B; --bg2:#04142E; --bg3:#020B18;
        --panel: rgba(255,255,255,.05);
        --panel2: rgba(4,20,46,.60);
        --border: rgba(255,255,255,.10);
        --border2: rgba(255,255,255,.15);
        --text: rgba(255,255,255,1);
        --muted: rgba(255,255,255,.70);
        --muted2: rgba(255,255,255,.60);
        --muted3: rgba(255,255,255,.45);
        --hover: rgba(255,255,255,.04);
      }

      *{box-sizing:border-box}
      body{
        margin:0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        color: var(--text);
        background: linear-gradient(to bottom, var(--bg1), var(--bg2), var(--bg3));
        min-height: 100vh;
      }
      .container{max-width:1100px; margin:0 auto; padding: 24px 18px 60px;}
      .topbar{
        position: sticky; top:0; z-index:10;
        border-bottom: 1px solid var(--border);
        background: rgba(3,18,42,.70);
        backdrop-filter: blur(10px);
      }
      .topbar-inner{
        max-width:1100px; margin:0 auto; padding: 14px 18px;
        display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      }
      .brand{display:flex; gap:12px; align-items:center;}
      .logo{
        width:40px; height:40px; border-radius:16px;
        border:1px solid var(--border2);
        background: var(--panel);
        display:grid; place-items:center;
        font-size:18px;
      }
      .kicker{font-size:11px; letter-spacing:.25em; text-transform:uppercase; color: var(--muted2);}
      .title{font-weight:900;}
      .tabs{display:flex; gap:10px; flex-wrap:wrap;}
      .tabbtn{
        border:1px solid var(--border2);
        background: var(--panel);
        color: rgba(255,255,255,.85);
        padding:10px 14px;
        border-radius: 12px;
        font-weight:900;
        cursor:pointer;
        transition: .15s ease;
      }
      .tabbtn:hover{background: rgba(255,255,255,.10)}
      .tabbtn.active{
        background: #fff;
        color: #061C3B;
        border-color: #fff;
      }

      .card{
        border:1px solid var(--border);
        background: var(--panel);
        border-radius: 22px;
        padding: 18px;
        box-shadow: 0 6px 24px rgba(0,0,0,.18);
      }
      .hero{border-radius: 26px; padding: 18px;}
      .row{display:flex; gap:14px; flex-wrap:wrap; align-items:flex-end; justify-content:space-between;}
      .pillgrid{display:flex; gap:10px; flex-wrap:wrap;}
      .metric{
        border:1px solid var(--border);
        background: var(--panel2);
        padding: 12px 14px;
        border-radius: 18px;
        min-width: 120px;
      }
      .metric .label{font-size:11px; letter-spacing:.08em; text-transform:uppercase; color: var(--muted2);}
      .metric .value{font-size:18px; font-weight:900; margin-top:2px;}
      .muted{color: var(--muted);}
      .muted2{color: var(--muted2);}
      .muted3{color: var(--muted3);}

      /* Table */
      .table-card{padding:0; overflow:hidden;}
      .table-head{
        padding: 16px 18px;
        border-bottom:1px solid var(--border);
        display:flex; gap:14px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      }
      .h2{font-size:18px; font-weight:900; margin:2px 0 0;}
      .search{
        display:flex; align-items:center; gap:10px;
        border:1px solid var(--border);
        background: rgba(4,20,46,.60);
        padding: 10px 12px;
        border-radius: 14px;
        min-width: 260px;
      }
      .search input{
        width:100%;
        background:transparent;
        border:none;
        outline:none;
        color:#fff;
        font-size:14px;
      }
      .search input::placeholder{color: rgba(255,255,255,.40)}
      .table-wrap{overflow-x:auto;}
      table{width:100%; border-collapse:collapse; min-width: 640px;}
      thead th{
        text-align:left;
        font-size:11px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color: var(--muted2);
        padding: 12px 18px;
        white-space:nowrap;
      }
      tbody td{
        padding: 12px 18px;
        border-top:1px solid var(--border);
        color: rgba(255,255,255,.80);
        font-size:14px;
        white-space:nowrap;
        vertical-align: top;
      }
      tbody tr:hover{background: var(--hover);}
      tbody tr.top3{background: rgba(255,255,255,.03);}
      td.highlight{font-weight:900; color:#fff;}

      /* Clickable team */
      .team-link{
        background: transparent;
        border: none;
        padding: 0;
        color: #fff;
        font-weight: 900;
        cursor: pointer;
        text-align: left;
      }
      .team-link:hover{ text-decoration: underline; }
      .chev{
        display:inline-block;
        width: 16px;
        color: rgba(255,255,255,.65);
        margin-right: 6px;
      }

      /* Roster row inside table */
      tr.roster-row:hover{background: transparent;}
      td.roster-cell{padding: 0; border-top: none;}
      .roster-panel{
        border-top: 1px solid var(--border);
        background: rgba(255,255,255,.03);
        padding: 14px 18px 18px;
      }
      .roster-head{
        font-size:11px;
        letter-spacing:.25em;
        text-transform:uppercase;
        color: var(--muted2);
      }
      .player-row{
        display:grid;
        grid-template-columns: 220px 1fr;
        gap: 10px 14px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 16px;
        background: rgba(4,20,46,.60);
        align-items:center;
        margin-top: 10px;
      }
      @media (max-width: 720px){
        .player-row{grid-template-columns: 1fr;}
      }
      .player-name{font-weight: 900; color: #fff;}
      .player-stats{
        display:flex;
        flex-wrap:wrap;
        gap: 8px 12px;
        color: rgba(255,255,255,.75);
        font-size: 12px;
      }
      .player-stats span{color: rgba(255,255,255,.50);}

      .footer{margin-top:34px; text-align:center; font-size:12px; color: var(--muted3);}
      .hidden{display:none !important;}
      .status{padding: 16px 18px; color: rgba(255,255,255,.80);}
      .error{padding: 16px 18px;}
      .error b{display:block; margin-bottom:6px;}
      .small{font-size:12px;}
    </style>
  </head>

  <body>
    <div class="topbar">
      <div class="topbar-inner">
        <div class="brand">
          <div class="logo">⚡</div>
          <div>
            <div class="kicker">Shotgun Pro League</div>
            <div class="title">Season 6</div>
          </div>
        </div>

        <div class="tabs" role="tablist" aria-label="Standings tabs">
          <button class="tabbtn active" data-tab="teams" role="tab" aria-selected="true">Team Rankings</button>
          <button class="tabbtn" data-tab="players" role="tab" aria-selected="false">Player Rankings</button>
        </div>
      </div>
    </div>

    <div class="container">
      <div id="status" class="card status">Loading standings…</div>

      <div id="content" class="hidden">
        <div class="card hero" style="margin-bottom:16px;">
          <div class="row">
            <div>
              <div class="kicker">Live Standings</div>
              <div class="muted small" style="margin-top:10px;">Click a team to view its roster.</div>
            </div>
            <div class="pillgrid">
              <div class="metric">
                <div class="label">Teams</div>
                <div class="value" id="teamCount">0</div>
              </div>
              <div class="metric">
                <div class="label">Players</div>
                <div class="value" id="playerCount">0</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Team standings (with embedded rosters) -->
        <div id="view-teams" class="card table-card">
          <div class="table-head">
            <div>
              <div class="kicker">Standings</div>
              <div class="h2">Team Rankings</div>
            </div>
            <div class="search">
              <span class="muted2">⌕</span>
              <input id="teamSearch" type="text" placeholder="Search…" />
            </div>
          </div>
          <div class="table-wrap">
            <table>
              <thead><tr id="teamHead"></tr></thead>
              <tbody id="teamBody"></tbody>
            </table>
          </div>
        </div>

        <!-- Player standings -->
        <div id="view-players" class="card table-card hidden" style="margin-top:16px;">
          <div class="table-head">
            <div>
              <div class="kicker">Standings</div>
              <div class="h2">Player Rankings</div>
            </div>
            <div class="search">
              <span class="muted2">⌕</span>
              <input id="playerSearch" type="text" placeholder="Search…" />
            </div>
          </div>
          <div class="table-wrap">
            <table>
              <thead><tr id="playerHead"></tr></thead>
              <tbody id="playerBody"></tbody>
            </table>
          </div>
        </div>

        <div class="footer">Shotgun Pro League • Season 6</div>
      </div>
    </div>

    <script>
      // ==============================
      // Config (not displayed publicly)
      // ==============================
      const WORKER_URL = "https://small-mud-2771.nextweekmedia.workers.dev/";
      const SHEET_ID   = "1qIM0HKhx9Y-3eCJCFzBqrbATwiPrK3C1ynATwZzRC1o";

      const RANGES = {
        teamInfo: "'Season 6, Stage 1'!A3:S63",
        teamStandings: "'Season 6, Stage 1'!U4:X15",
        playerStandings: "'Season 6, Stage 1'!AE4:AH101",
      };

      // If your player standings range includes a header row, set true.
      const USE_FIRST_ROW_AS_HEADER = false;

      // Team standings UI wants: Rank | Team | Points
      const TEAM_STANDINGS_HEADERS   = ["Rank","Team","Points"];
      const PLAYER_STANDINGS_HEADERS = ["Rank","Player","Points","Notes"];

      // ==============================
      // Fetch helpers
      // ==============================
      function normalizeValues(resp){
        if(!resp) return [];
        if(Array.isArray(resp)) return resp;
        if(Array.isArray(resp.values)) return resp.values;
        if(Array.isArray(resp.data?.values)) return resp.data.values;
        if(Array.isArray(resp.result?.values)) return resp.result.values;
        return [];
      }

      function rowHasAnyValue(row){
        return Array.isArray(row) && row.some(c => String(c ?? "").trim() !== "");
      }

      async function fetchRange(range){
        const payload = { sheetId: SHEET_ID, range };

        // Try POST first
        try{
          const r = await fetch(WORKER_URL, {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify(payload),
          });
          if(r.ok) return await r.json();
        }catch(e){ /* fall back */ }

        // Fallback: GET params
        const u = new URL(WORKER_URL);
        u.searchParams.set("sheetId", SHEET_ID);
        u.searchParams.set("range", range);
        const r2 = await fetch(u.toString());
        if(!r2.ok){
          const text = await r2.text().catch(()=>"");
          throw new Error(`Worker request failed (${r2.status}). ${text}`.trim());
        }
        return await r2.json();
      }

      // ==============================
      // Standings parsing
      // ==============================
      function splitHeaderAndRows(values, fallbackHeaders){
        const cleaned = (values || []).filter(rowHasAnyValue);
        if(!cleaned.length) return { headers: fallbackHeaders, rows: [] };

        if(USE_FIRST_ROW_AS_HEADER){
          const headers = cleaned[0].map((h,i)=> String(h ?? fallbackHeaders[i] ?? `Col ${i+1}`));
          return { headers, rows: cleaned.slice(1) };
        }
        return { headers: fallbackHeaders, rows: cleaned };
      }

      // Your sheet has: team name in the "points" column and team score in the "notes" column.
      // Instead of hard-coding indices, we map using "last 2 cells" for robustness:
      //   rank = first cell
      //   team = second-to-last cell
      //   pts  = last cell
      function remapTeamStandingsRow(r){
        const arr = Array.isArray(r) ? r : [];
        const rank = arr[0] ?? "";
        const team = arr.length >= 2 ? arr[arr.length - 2] : "";
        const pts  = arr.length >= 1 ? arr[arr.length - 1] : "";
        return [rank, team, pts];
      }

      // ==============================
      // Roster parsing (FULL TEAM & PLAYER RANGE formatting)
      // ==============================
      function firstNonEmptyIndex(row){
        if(!Array.isArray(row)) return -1;
        for(let i=0;i<row.length;i++){
          if(String(row[i] ?? "").trim() !== "") return i;
        }
        return -1;
      }
      function firstNonEmptyCell(row){
        const idx = firstNonEmptyIndex(row);
        return idx >= 0 ? String(row[idx] ?? "").trim() : "";
      }

      // IMPORTANT CHANGE:
      // - Header row exists (used for labeling)
      // - Then repeating pattern: team row (team name) + 4 player rows
      // - For player rows: first non-empty cell is player name; remaining filled cells are player stats
      function chunkTeamsFromRange(rangeValues){
        const cleaned = (rangeValues || []).filter(rowHasAnyValue);
        if(!cleaned.length) return { header: [], teams: [] };

        const header = cleaned[0] || [];
        const rows = cleaned.slice(1);

        const headerLabels = header.map(h => String(h ?? "").trim());

        function labelForCol(j){
          const h = headerLabels[j];
          return (h && h.trim()) ? h.trim() : `Col ${j+1}`;
        }

        function extractStats(row, nameIdx){
          const stats = [];
          const r = row || [];
          for(let j=0; j<r.length; j++){
            if(j === nameIdx) continue;
            const v = String(r[j] ?? "").trim();
            if(!v) continue;
            stats.push({ key: labelForCol(j), value: v });
          }
          return stats;
        }

        const teams = [];
        for(let i=0; i<rows.length; i+=5){
          const teamRow = rows[i] || [];
          const playerRows = [rows[i+1], rows[i+2], rows[i+3], rows[i+4]].filter(Boolean);

          // Team name = first non-empty cell of team row (NOT a fixed column)
          const teamName = firstNonEmptyCell(teamRow) || `Team ${Math.floor(i/5)+1}`;

          const players = playerRows.map((pr, idx)=>{
            const nameIdx = firstNonEmptyIndex(pr);
            const playerName = (nameIdx >= 0 ? String(pr[nameIdx] ?? "").trim() : "") || firstNonEmptyCell(pr) || `Player ${idx+1}`;
            const stats = extractStats(pr, nameIdx >= 0 ? nameIdx : 0);
            return { name: playerName, stats };
          });

          teams.push({ teamName, players });
        }

        return { header: headerLabels, teams };
      }

      // ==============================
      // Matching team names between standings + roster range
      // ==============================
      function normName(s){
        return String(s ?? "")
          .trim()
          .toLowerCase()
          .replace(/\s+/g, " ")
          .replace(/[’']/g, "'"); // normalize apostrophes a bit
      }
      function simplify(s){
        return normName(s).replace(/[^a-z0-9 ]+/g, "").trim();
      }

      function buildRosterMap(teams){
        const m = new Map();
        teams.forEach(t => m.set(normName(t.teamName), t));
        return m;
      }

      // Tries exact match, then simplified match, then substring match
      function findRosterTeam(rosterMap, teamDisplayName){
        const k = normName(teamDisplayName);
        if(rosterMap.has(k)) return rosterMap.get(k);

        const ks = simplify(teamDisplayName);
        if(!ks) return null;

        // simplified exact
        for(const [key, team] of rosterMap.entries()){
          if(simplify(key) === ks) return team;
        }

        // substring / contains (best-effort)
        let best = null;
        let bestScore = 0;
        for(const [key, team] of rosterMap.entries()){
          const a = simplify(key);
          if(!a) continue;
          if(a.includes(ks) || ks.includes(a)){
            const score = Math.min(a.length, ks.length);
            if(score > bestScore){
              bestScore = score;
              best = team;
            }
          }
        }
        return best;
      }

      // ==============================
      // DOM helpers
      // ==============================
      function el(tag, attrs={}, children=[]){
        const node = document.createElement(tag);
        for(const [k,v] of Object.entries(attrs)){
          if(k === "class") node.className = v;
          else if(k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2).toLowerCase(), v);
          else node.setAttribute(k, v);
        }
        for(const ch of children){
          if(ch == null) continue;
          if(typeof ch === "string") node.appendChild(document.createTextNode(ch));
          else node.appendChild(ch);
        }
        return node;
      }

      function clearTable(headEl, bodyEl, headers){
        headEl.innerHTML = "";
        bodyEl.innerHTML = "";
        headers.forEach(h => headEl.appendChild(el("th", {}, [String(h ?? "")])));
      }

      // ==============================
      // Rendering
      // ==============================
      function renderRosterPanel(teamDisplayName, rosterTeam){
        const panel = el("div", { class:"roster-panel" }, [
          el("div", { class:"roster-head" }, ["Roster"]),
        ]);

        if(!rosterTeam || !rosterTeam.players || !rosterTeam.players.length){
          panel.appendChild(el("div", { class:"muted small", style:"margin-top:8px;" }, [
            `No roster found for "${teamDisplayName}".`
          ]));
          return panel;
        }

        rosterTeam.players.forEach(p=>{
          const statsLine = el("div", { class:"player-stats" }, []);
          if(p.stats && p.stats.length){
            p.stats.forEach(s=>{
              statsLine.appendChild(el("div", {}, [
                el("span", {}, [s.key + ": "]),
                s.value
              ]));
            });
          } else {
            statsLine.appendChild(el("div", { class:"muted3" }, ["No stats available."]));
          }

          panel.appendChild(
            el("div", { class:"player-row" }, [
              el("div", { class:"player-name" }, [p.name]),
              statsLine
            ])
          );
        });

        return panel;
      }

      function renderTeamStandingsWithRosters(headEl, bodyEl, rows, rosterMap, expandedSet){
        clearTable(headEl, bodyEl, TEAM_STANDINGS_HEADERS);

        if(!rows.length){
          bodyEl.appendChild(
            el("tr", {}, [
              el("td", { colspan: TEAM_STANDINGS_HEADERS.length, class:"muted" }, ["No teams found."])
            ])
          );
          return;
        }

        rows.forEach((row, rIdx)=>{
          const [rank, team, pts] = row;
          const teamKey = normName(team);
          const isExpanded = expandedSet.has(teamKey);
          const chev = isExpanded ? "▾" : "▸";

          // Main standings row
          const tr = el("tr", { class: (rIdx < 3 ? "top3" : "") }, []);
          tr.appendChild(el("td", {}, [String(rank ?? "").trim()]));

          const teamBtn = el("button", {
            class: "team-link",
            "data-team": teamKey,
            "aria-expanded": isExpanded ? "true" : "false",
            type: "button",
          }, [
            el("span", { class:"chev", "aria-hidden":"true" }, [chev]),
            String(team ?? "").trim()
          ]);

          tr.appendChild(el("td", { class:"highlight" }, [teamBtn]));
          tr.appendChild(el("td", {}, [String(pts ?? "").trim()]));
          bodyEl.appendChild(tr);

          // Collapsible roster row
          const rosterTr = el("tr", { class:"roster-row" }, []);
          const rosterTd = el("td", { class:"roster-cell", colspan: TEAM_STANDINGS_HEADERS.length }, []);
          rosterTr.appendChild(rosterTd);

          if(isExpanded){
            const rosterTeam = findRosterTeam(rosterMap, team);
            rosterTd.appendChild(renderRosterPanel(team, rosterTeam));
          }

          bodyEl.appendChild(rosterTr);
        });
      }

      function renderSimpleTable(headEl, bodyEl, headers, rows, highlightIdx=1, emptyText="No results."){
        headEl.innerHTML = "";
        bodyEl.innerHTML = "";
        headers.forEach(h => headEl.appendChild(el("th", {}, [String(h ?? "")])));

        if(!rows.length){
          bodyEl.appendChild(
            el("tr", {}, [
              el("td", { colspan: headers.length, class:"muted" }, [emptyText])
            ])
          );
          return;
        }

        rows.forEach((row, rIdx)=>{
          const tr = el("tr", { class: (rIdx < 3 ? "top3" : "") }, []);
          headers.forEach((_, cIdx)=>{
            tr.appendChild(
              el("td", { class: (cIdx === highlightIdx ? "highlight" : "") }, [String(row?.[cIdx] ?? "").trim()])
            );
          });
          bodyEl.appendChild(tr);
        });
      }

      function setActiveTab(tab){
        document.querySelectorAll(".tabbtn").forEach(btn=>{
          const active = btn.dataset.tab === tab;
          btn.classList.toggle("active", active);
          btn.setAttribute("aria-selected", active ? "true" : "false");
        });
        document.getElementById("view-teams").classList.toggle("hidden", tab !== "teams");
        document.getElementById("view-players").classList.toggle("hidden", tab !== "players");
      }

      // ==============================
      // App state + wiring
      // ==============================
      const statusEl  = document.getElementById("status");
      const contentEl = document.getElementById("content");

      const teamCountEl = document.getElementById("teamCount");
      const playerCountEl = document.getElementById("playerCount");

      const teamHead = document.getElementById("teamHead");
      const teamBody = document.getElementById("teamBody");
      const playerHead = document.getElementById("playerHead");
      const playerBody = document.getElementById("playerBody");

      const teamSearch = document.getElementById("teamSearch");
      const playerSearch = document.getElementById("playerSearch");

      let rawTeamStandings = [];
      let rawPlayerStandings = [];
      let rosterMap = new Map();      // key: normalized roster team name -> { teamName, players }
      let expandedTeams = new Set();  // key: normalized TEAM NAME FROM STANDINGS (post-remap)

      let filteredTeamRows = [];
      let filteredPlayerRows = [];
      let playerHeaders = PLAYER_STANDINGS_HEADERS;

      function applyFiltersAndRender(){
        const tQ = teamSearch.value.trim().toLowerCase();
        const pQ = playerSearch.value.trim().toLowerCase();

        // Team standings: split then remap and drop notes column
        const tSplitRaw = splitHeaderAndRows(rawTeamStandings, ["Rank","(unused)","(team)","(score)"]);
        const tMappedRows = tSplitRaw.rows.map(remapTeamStandingsRow);

        filteredTeamRows = tMappedRows.filter(r =>
          r.map(c => String(c ?? "").toLowerCase()).join(" ").includes(tQ)
        );

        // Player standings
        const pSplit = splitHeaderAndRows(rawPlayerStandings, PLAYER_STANDINGS_HEADERS);
        playerHeaders = pSplit.headers;
        filteredPlayerRows = pSplit.rows.filter(r =>
          r.map(c => String(c ?? "").toLowerCase()).join(" ").includes(pQ)
        );

        renderTeamStandingsWithRosters(teamHead, teamBody, filteredTeamRows, rosterMap, expandedTeams);
        renderSimpleTable(playerHead, playerBody, playerHeaders, filteredPlayerRows, 1, "No players found.");
      }

      // Team roster toggles (event delegation)
      teamBody.addEventListener("click", (e)=>{
        const btn = e.target.closest(".team-link");
        if(!btn) return;

        const key = btn.getAttribute("data-team");
        if(!key) return;

        if(expandedTeams.has(key)) expandedTeams.delete(key);
        else expandedTeams.add(key);

        renderTeamStandingsWithRosters(teamHead, teamBody, filteredTeamRows, rosterMap, expandedTeams);
      });

      document.querySelectorAll(".tabbtn").forEach(btn=>{
        btn.addEventListener("click", ()=> setActiveTab(btn.dataset.tab));
      });

      teamSearch.addEventListener("input", ()=>{
        expandedTeams = new Set(); // collapse on filter changes
        applyFiltersAndRender();
      });
      playerSearch.addEventListener("input", applyFiltersAndRender);

      // ==============================
      // Boot
      // ==============================
      (async function init(){
        try{
          statusEl.textContent = "Loading standings…";

          const [teamInfoResp, teamStResp, playerStResp] = await Promise.all([
            fetchRange(RANGES.teamInfo),        // full team & player range
            fetchRange(RANGES.teamStandings),
            fetchRange(RANGES.playerStandings),
          ]);

          // Build roster map using the EXACT formatting of the full team & player range
          const teamInfoValues = normalizeValues(teamInfoResp);
          const { teams } = chunkTeamsFromRange(teamInfoValues);
          rosterMap = buildRosterMap(teams);

          rawTeamStandings = normalizeValues(teamStResp);
          rawPlayerStandings = normalizeValues(playerStResp);

          teamCountEl.textContent = String(teams.length);
          playerCountEl.textContent = String(teams.length * 4);

          applyFiltersAndRender();

          statusEl.classList.add("hidden");
          contentEl.classList.remove("hidden");
          setActiveTab("teams");
        }catch(err){
          statusEl.classList.remove("hidden");
          statusEl.classList.add("error");
          statusEl.innerHTML = `
            <b>Couldn’t load data</b>
            <div class="muted">${(err && err.message) ? err.message : "Failed to load standings."}</div>
            <div class="muted3 small" style="margin-top:10px;">
              Tip: your Worker might require a different request shape. Update <code>fetchRange()</code> in this file to match your existing site.
            </div>
          `;
          console.error(err);
        }
      })();
    </script>
  </body>
</html>
