<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NSS Golf Community</title>

  <style>
    :root{
      --bg1:#061C3B; --bg2:#04142E; --bg3:#020B18;

      --card-bg: rgba(15,23,42,1);
      --card-shadow: 0 32px 32px rgba(0,0,0,0.65);

      --text: #e9eef8;
      --title: #c7d7ff;
      --muted: #9ca3c7;

      --border-lite: rgba(148,163,184,0.20);
      --btn-bg: rgba(255,255,255,0.06);
      --btn-bg-hover: rgba(255,255,255,0.10);
      --btn-border: rgba(255,255,255,0.15);
      --btn-border-hover: rgba(255,255,255,0.28);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      background: linear-gradient(to bottom, var(--bg1), var(--bg2), var(--bg3));
    }

    .topbar{
      position: sticky; top:0; z-index:10;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(3,18,42,.70);
      backdrop-filter: blur(10px);
    }
    .topbar-inner{
      max-width:1100px;
      margin:0 auto;
      padding: 14px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{display:flex; gap:12px; align-items:center;}
    .home-badge{
      width:40px; height:40px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.05);
      display:grid; place-items:center;
      overflow:hidden;
      user-select:none;
    }
    .home-badge img{
      width:70%;
      height:70%;
      object-fit: contain;
      display:block;
      pointer-events:none;
    }

    .kicker{
      font-size:11px;
      letter-spacing:.25em;
      text-transform:uppercase;
      color: rgba(255,255,255,.65);
      font-weight:900;
    }

    .container{
      max-width:1100px;
      margin:0 auto;
      padding: 28px 18px 56px;
      display:flex;
      justify-content:center;
    }

    .card{
      width: min(820px, 100%);
      background: var(--card-bg);
      border-radius: 20px;
      padding: 22px 20px;
      box-shadow: var(--card-shadow);
      border: 1px solid rgba(255,255,255,0.10);
    }

    .headline{
      font-size: 22px;
      font-weight: 950;
      color: var(--title);
      letter-spacing: .035em;
      text-transform: uppercase;
      margin: 0 0 10px 0;
    }

    .copy{
      margin: 0;
      color: rgba(233,238,248,0.92);
      font-size: 15px;
      line-height: 1.55;
      font-weight: 700;
    }

    .actions{
      margin-top: 18px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: center;
      padding-top: 16px;
      border-top: 1px solid var(--border-lite);
    }

    .league-tabs{
      margin: 16px 0 0;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .tab-button{
      appearance:none;
      -webkit-appearance:none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: rgba(255,255,255,0.92);
      padding: 10px 16px;
      border-radius: 999px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .10em;
      font-size: 11px;
      cursor:pointer;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      line-height: 1;
      flex: 1 1 0;
      min-width: 160px;
    }

    .tab-button.is-active{
      background: rgba(255,255,255,0.18);
      border-color: rgba(255,255,255,0.45);
      color: #fff;
    }

    .league-section{
      margin-top: 18px;
      padding-top: 16px;
      border-top: 1px solid var(--border-lite);
      text-align: center;
    }

    .league-section[hidden]{
      display: none;
    }

    .league-placeholder{
      margin: 0;
      font-size: 14px;
      color: rgba(233,238,248,0.72);
      font-weight: 600;
    }

    .video-section{
      margin-top: 22px;
      padding-top: 18px;
      border-top: 1px solid var(--border-lite);
    }

    .video-header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .video-controls{
      margin-top: 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .video-controls .video-status{
      margin-top: 0;
    }

    .section-title{
      margin: 0;
      font-size: 18px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--title);
    }

    .sort-control{
      display:flex;
      align-items:center;
      gap: 8px;
      font-size: 12px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: rgba(255,255,255,0.7);
    }

    .sort-control select{
      background: var(--btn-bg);
      border: 1px solid var(--btn-border);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .video-status{
      margin-top: 6px;
      font-size: 13px;
      color: rgba(233,238,248,0.7);
      font-weight: 600;
      white-space: pre-wrap;
    }

    .live-status{
      margin-top: 16px;
    }

    .pagination-bar{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      margin: 12px 0 14px;
      flex-wrap: wrap;
    }

    .pagination-bar[hidden]{
      display:none;
    }

    .pagination-button{
      appearance:none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: rgba(255,255,255,0.92);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 800;
      font-size: 12px;
      cursor:pointer;
      letter-spacing: .08em;
      text-transform: uppercase;
    }

    .pagination-button:hover{
      background: var(--btn-bg-hover);
      border-color: var(--btn-border-hover);
    }

    .pagination-button[disabled]{
      opacity: 0.45;
      cursor: not-allowed;
    }

    .pagination-button.is-active{
      background: rgba(255,255,255,0.18);
      border-color: rgba(255,255,255,0.35);
    }

    .video-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .live-section{
      margin-top: 16px;
    }

    .live-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin: 14px 0 12px;
    }

    .live-card{
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding: 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(6,24,46,0.7);
    }

    .live-thumb{
      width:100%;
      aspect-ratio: 16 / 9;
      border-radius: 12px;
      object-fit: cover;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .live-title{
      font-size: 14px;
      font-weight: 800;
      margin: 0;
      color: var(--text);
      text-decoration: none;
    }

    .live-title:hover{
      text-decoration: underline;
    }

    .live-meta{
      display:flex;
      align-items:center;
      gap: 8px;
      color: rgba(233,238,248,0.7);
      font-size: 12px;
      font-weight: 700;
    }

    .live-badge{
      background:#ff3558;
      color:#fff;
      font-weight:800;
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      letter-spacing: .08em;
    }

    .live-platform{
      background: rgba(255,255,255,0.12);
      color:#fff;
      font-weight:700;
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: .06em;
    }

    .video-card{
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding: 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(6,24,46,0.7);
    }

    .video-thumb{
      width:100%;
      aspect-ratio: 16 / 9;
      border-radius: 12px;
      object-fit: cover;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .video-title{
      font-size: 14px;
      font-weight: 800;
      margin: 0;
      color: var(--text);
      text-decoration: none;
    }

    .video-title:hover{
      text-decoration: underline;
    }

    .video-meta{
      font-size: 12px;
      color: rgba(233,238,248,0.7);
      display:flex;
      flex-direction:column;
      gap: 6px;
      font-weight: 600;
    }

    .video-meta-line{
      display:flex;
      align-items:center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .video-channel{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
    }

    .video-channel-avatar{
      width: 24px;
      height: 24px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid rgba(255,255,255,0.2);
      flex-shrink: 0;
    }

    .video-channel-avatar-placeholder{
      display:grid;
      place-items:center;
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.9);
      font-size: 11px;
      font-weight: 900;
      letter-spacing: .02em;
      text-transform: uppercase;
    }

    .video-channel-name{
      color: var(--text);
      font-weight: 700;
      text-decoration: none;
    }

    .video-channel-name:hover{
      text-decoration: underline;
    }

    .video-meta-sep{
      color: rgba(233,238,248,0.45);
    }

    .video-meta-muted{
      color: rgba(233,238,248,0.7);
    }

    .channel-card{
      display:flex;
      flex-direction:column;
      gap: 12px;
      padding: 16px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(6,24,46,0.7);
      min-height: 168px;
    }

    .channel-banner{
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      min-height: 92px;
    }

    .channel-banner img{
      width: 100%;
      height: 100%;
      min-height: 92px;
      object-fit: cover;
      display: block;
    }

    .channel-avatar-wrap{
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translate(-50%, 50%);
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: rgba(6,24,46,0.9);
      display: grid;
      place-items: center;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .channel-avatar{
      width: 56px;
      height: 56px;
      border-radius: 50%;
      object-fit: cover;
      display:block;
    }

    .channel-avatar-placeholder{
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: rgba(255,255,255,0.06);
      display:grid;
      place-items:center;
      font-weight: 950;
      color: rgba(255,255,255,0.85);
      letter-spacing: .04em;
      user-select: none;
    }

    .channel-body{
      display:flex;
      flex-direction:column;
      align-items:center;
      text-align:center;
      padding-top: 22px;
      gap: 8px;
    }

    .channel-name{
      font-size: 15px;
      font-weight: 900;
      margin: 0;
      color: var(--text);
      word-break: break-word;
    }

    .channel-meta{
      font-size: 12px;
      color: rgba(233,238,248,0.7);
      display:flex;
      flex-direction:column;
      gap: 4px;
      font-weight: 600;
      align-items:center;
    }

    .btn{
      appearance:none;
      -webkit-appearance:none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: rgba(255,255,255,0.92);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 950;
      text-transform: uppercase;
      letter-spacing: .10em;
      font-size: 12px;
      cursor:pointer;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      line-height: 1;
    }
    .btn.neon-red{
      color: #ff5a5a;
      border-color: rgba(255,90,90,0.9);
      box-shadow: 0 0 12px rgba(255,90,90,0.45), 0 0 24px rgba(255,90,90,0.2);
      text-shadow: 0 0 8px rgba(255,90,90,0.9);
    }
    .btn.neon-blue{
      color: #7dd3fc;
      border-color: rgba(125,211,252,0.9);
      box-shadow: 0 0 12px rgba(125,211,252,0.45), 0 0 24px rgba(125,211,252,0.2);
      text-shadow: 0 0 8px rgba(125,211,252,0.9);
    }
    .btn.neon-green{
      color: #5dff9c;
      border-color: rgba(93,255,156,0.9);
      box-shadow: 0 0 12px rgba(93,255,156,0.45), 0 0 24px rgba(93,255,156,0.2);
      text-shadow: 0 0 8px rgba(93,255,156,0.9);
    }
    .btn-icon{
      width: 16px;
      height: 16px;
      display: block;
    }
    .btn:hover{
      background: var(--btn-bg-hover);
      border-color: var(--btn-border-hover);
    }

    .footer{
      margin-top: 18px;
      text-align:center;
      font-size:12px;
      color: rgba(233,238,248,0.55);
    }

    @media (max-width: 760px){
      .container{ padding: 20px 12px 44px; }
      .topbar-inner{ padding: 12px 12px; flex-wrap: nowrap; }
      .brand{ flex: 1; min-width: 0; }
      .discord-button{ padding: 8px 10px; font-size: 10px; letter-spacing: .06em; }
      .discord-button .btn-icon{ width: 14px; height: 14px; }
      .headline{ font-size: 18px; }
      .card{ padding: 18px 14px; border-radius: 18px; }
      .league-tabs{
        display:grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .tab-button{
        min-width: 0;
      }
      .tab-button.tab-primary{
        grid-column: 1 / -1;
      }
    }

    @media (min-width: 761px){
      .video-grid,
      .live-grid{
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="home-badge" aria-hidden="true">
          <img src="/logos/golf.png" alt="Home" loading="eager" decoding="async" />
        </div>
        <div>
          <div class="kicker">NSS Golf Community</div>
        </div>
      </div>
      <a class="btn discord-button" href="https://discord.gg/VfTX9BwuTH" target="_blank" rel="noopener noreferrer" aria-label="Join our Discord">
        <img class="btn-icon" src="/logos/discord.svg" alt="" aria-hidden="true" />
        DISCORD
      </a>
    </div>
  </div>

  <div class="container">
    <div class="card">
      <h1 class="headline">Leagues &amp; Events</h1>
      <div class="league-tabs" role="tablist" aria-label="League sections">
        <button class="tab-button tab-primary is-active" id="happening-now-tab" type="button" role="tab" aria-selected="true" aria-controls="happening-now-section" data-target="happening-now-section">
          Happening Now
        </button>
        <button class="tab-button" id="upcoming-tab" type="button" role="tab" aria-selected="false" aria-controls="upcoming-section" data-target="upcoming-section">
          Upcoming
        </button>
        <button class="tab-button" id="archive-tab" type="button" role="tab" aria-selected="false" aria-controls="archive-section" data-target="archive-section">
          Archive
        </button>
      </div>

      <div class="league-section" id="happening-now-section" aria-labelledby="happening-now-tab">
        <div class="actions">
          <a class="btn neon-red" href="https://teamupdiscord.com/leaderboard/client/DISCORD%7C1069003073311211601/leaderboard/Season_11/rating_type/player_global_all/format/global" target="_blank" rel="noopener noreferrer" aria-label="Open Ranked League Leaderboard">
            Ranked League - Season 11
          </a>

          <a class="btn neon-blue" href="/proleague" aria-label="Go to Pro League">
            Shotgun Pro League - Season 6
          </a>

          <a class="btn neon-green" href="/worldopen/index.html" aria-label="Go to World Open 2026">
            World Open 2026
          </a>
        </div>
      </div>

      <div class="league-section" id="upcoming-section" aria-labelledby="upcoming-tab" hidden>
        <p class="league-placeholder">Nothing here... yet.</p>
      </div>

      <div class="league-section" id="archive-section" aria-labelledby="archive-tab" hidden>
        <p class="league-placeholder">Nothing here... yet.</p>
      </div>

      <section class="video-section" aria-labelledby="video-section-title">
        <div class="video-header">
          <h2 class="section-title" id="video-section-title">Community Content</h2>
        </div>
        <section class="live-section" id="live-section" aria-labelledby="live-section-title" hidden>
          <div class="video-header">
            <h2 class="section-title" id="live-section-title">Live Now</h2>
          </div>
          <div class="video-status live-status" id="live-status"></div>
          <div class="live-grid video-grid" id="live-grid"></div>
        </section>
        <div class="video-header">
          <h2 class="section-title" id="videos-section-title">Videos</h2>
        </div>
        <div class="video-controls">
          <div class="video-status" id="video-status"></div>
          <label class="sort-control" for="video-sort">
            Sort
            <select id="video-sort">
              <option value="recent">Most Recent</option>
              <option value="views">Most Viewed</option>
              <option value="channels">Channels</option>
            </select>
          </label>
        </div>
        <nav class="pagination-bar" id="video-pagination-top" aria-label="Video pages"></nav>
        <div class="video-grid" id="video-grid"></div>
        <nav class="pagination-bar" id="video-pagination-bottom" aria-label="Video pages"></nav>
      </section>

      <div class="footer">NSS Golf Community Events</div>
    </div>
  </div>

  <script>
    // === CONFIG ===
    // REQUIRED: Worker must implement GET /proxy?url=<encoded> and return CORS headers.
    const WORKER_URL = "https://small-mud-2771.nextweekmedia.workers.dev/";
    const SHEET_ID = "1VGouXR7onYOeu7T4oiFSId-TtdJMFS0Nc3CYcjYM6-k";
    const SHEET_NAME = "Channels";

    // === ELEMENTS ===
    const statusEl = document.getElementById("video-status");
    const gridEl = document.getElementById("video-grid");
    const sortEl = document.getElementById("video-sort");
    const paginationTopEl = document.getElementById("video-pagination-top");
    const paginationBottomEl = document.getElementById("video-pagination-bottom");
    const liveStatusEl = document.getElementById("live-status");
    const liveGridEl = document.getElementById("live-grid");
    const liveSectionEl = document.getElementById("live-section");
    const leagueTabs = Array.from(document.querySelectorAll(".tab-button[data-target]"));
    const leagueSections = Array.from(document.querySelectorAll(".league-section"));

    // === STATE ===
    const STATE = {
      channels: [],
      videos: [],
      liveNow: [],
      errors: [],
      currentPage: 1,
      pageSize: 25,
      viewsReady: false,
    };

    // === SHEETS ===
    function normalizeValues(resp){
      if(!resp) return [];
      if(Array.isArray(resp)) return resp;
      if(Array.isArray(resp.values)) return resp.values;
      if(Array.isArray(resp.data?.values)) return resp.data.values;
      if(Array.isArray(resp.result?.values)) return resp.result.values;
      return [];
    }

    async function fetchRange(a1){
      const range = `'${SHEET_NAME}'!${a1}`;
      const payload = { sheetId: SHEET_ID, range };

      try{
        const r = await fetch(WORKER_URL, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify(payload),
        });
        if(r.ok) return normalizeValues(await r.json());
      }catch(e){}

      const u = new URL(WORKER_URL);
      u.searchParams.set("sheetId", SHEET_ID);
      u.searchParams.set("range", range);
      const r2 = await fetch(u.toString());
      if(!r2.ok){
        const text = await r2.text().catch(()=> "");
        throw new Error(`Worker request failed (${r2.status}). ${text}`.trim());
      }
      return normalizeValues(await r2.json());
    }

    // === TIME WINDOW ===
    function getRolling90DaysWindow(){
      const end = new Date();
      const start = new Date(end);
      start.setDate(start.getDate() - 90);
      return { start, end };
    }

    // === WORKER PROXY / ENDPOINTS ===
    function workerProxyUrl(targetUrl){
      const base = WORKER_URL.endsWith("/") ? WORKER_URL : (WORKER_URL + "/");
      return `${base}proxy?url=${encodeURIComponent(targetUrl)}`;
    }

    function workerEndpoint(path, params = {}){
      const base = WORKER_URL.endsWith("/") ? WORKER_URL : (WORKER_URL + "/");
      const url = new URL(path.replace(/^\//, ""), base);
      for(const [key, value] of Object.entries(params)){
        if(value !== undefined && value !== null){
          url.searchParams.set(key, String(value));
        }
      }
      return url.toString();
    }

    async function fetchWithTimeout(url, { timeoutMs = 15000, ...opts } = {}){
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), timeoutMs);
      try{
        return await fetch(url, { ...opts, signal: controller.signal });
      }finally{
        clearTimeout(t);
      }
    }

    async function fetchTextViaProxy(url){
      const proxied = workerProxyUrl(url);
      const res = await fetchWithTimeout(proxied, { timeoutMs: 20000 });
      if(!res.ok){
        const text = await res.text().catch(()=> "");
        throw new Error(`Proxy fetch failed (${res.status}). ${text}`.trim());
      }
      return res.text();
    }

    async function fetchJsonViaProxy(url){
      const proxied = workerProxyUrl(url);
      const res = await fetchWithTimeout(proxied, { timeoutMs: 20000 });
      if(!res.ok){
        const text = await res.text().catch(()=> "");
        throw new Error(`Proxy fetch failed (${res.status}). ${text}`.trim());
      }
      return res.json();
    }

    // =========================
    // NEW: YouTube video stats via Worker
    // GET /yt/videos?ids=...
    // =========================
    async function fetchVideoStats(videoIds){
      if(!videoIds?.length) return new Map();
      const unique = Array.from(new Set(videoIds)).filter(Boolean);

      const statsById = new Map();
      for(let i = 0; i < unique.length; i += 50){
        const batch = unique.slice(i, i + 50);
        const endpoint = workerEndpoint("yt/videos", { ids: batch.join(",") });
        const res = await fetchWithTimeout(endpoint, { timeoutMs: 20000 });
        if(!res.ok){
          console.warn("yt/videos failed", res.status);
          continue;
        }

        const data = await res.json();
        for(const item of (data?.items || [])){
          statsById.set(item.id, item);
        }
      }
      return statsById;
    }

    // === CHANNEL INPUT PARSING ===
    function stripTrailingSlash(value){
      return value.endsWith("/") ? value.slice(0, -1) : value;
    }

    function parseChannelUrl(entry){
      const raw = String(entry ?? "").trim();
      if(!raw) return null;
      try{
        const url = new URL(raw);
        const host = url.hostname.replace(/^www\./, "");
        if(host !== "youtube.com" && host !== "m.youtube.com" && host !== "youtu.be"){
          return null;
        }
        return stripTrailingSlash(url.href);
      }catch{
        return null;
      }
    }

    function parseTwitchEntry(entry){
      const raw = String(entry ?? "").trim();
      if(!raw) return null;

      if(raw.toLowerCase().startsWith("twitch:")){
        const channel = raw.slice(7).trim();
        if(!channel) return null;
        return { platform: "twitch", channel, url: `https://www.twitch.tv/${channel}` };
      }

      try{
        const url = new URL(raw);
        const host = url.hostname.replace(/^www\./, "");
        if(host !== "twitch.tv") return null;
        const channel = url.pathname.split("/").filter(Boolean)[0];
        if(!channel) return null;
        return { platform: "twitch", channel, url: `https://www.twitch.tv/${channel}` };
      }catch{
        return null;
      }
    }

    function parseChannelEntry(entry){
      const twitchEntry = parseTwitchEntry(entry);
      if(twitchEntry) return twitchEntry;

      const raw = String(entry ?? "").trim();
      if(!raw) return null;

      if(/^UC[a-zA-Z0-9_-]{20,}$/.test(raw)){
        return { platform: "youtube", url: `https://www.youtube.com/channel/${raw}`, id: raw, raw };
      }

      const url = parseChannelUrl(raw);
      if(!url) return null;
      return { platform: "youtube", url, id: null, raw };
    }

    // === CHANNEL ID RESOLUTION ===
    function extractChannelIdFromHtml(html){
      return (
        html.match(/"channelId":"(UC[^"]+)"/)?.[1] ||
        html.match(/"externalId":"(UC[^"]+)"/)?.[1] ||
        html.match(/"browseId":"(UC[^"]+)"/)?.[1] ||
        null
      );
    }

    async function resolveChannelId(channelUrl){
      try{
        const url = new URL(channelUrl);

        if(url.pathname.startsWith("/channel/")){
          const maybe = url.pathname.split("/")[2] || null;
          if(maybe && maybe.startsWith("UC")) return maybe;
        }

        const html = await fetchTextViaProxy(url.href);
        return extractChannelIdFromHtml(html);
      }catch(error){
        console.warn("Channel lookup failed.", channelUrl, error);
        return null;
      }
    }

    // === CHANNEL DISPLAY NAME + AVATAR ===
    async function fetchChannelOEmbed(channelUrl){
      const endpoint = `https://www.youtube.com/oembed?format=json&url=${encodeURIComponent(channelUrl)}`;
      return fetchJsonViaProxy(endpoint);
    }

    async function fetchChannelMetadata(channelId){
      const endpoint = workerEndpoint("yt/channel", { channelId });
      const res = await fetchWithTimeout(endpoint, { timeoutMs: 20000 });
      if(!res.ok){
        const text = await res.text().catch(()=> "");
        throw new Error(`Channel metadata failed (${res.status}). ${text}`.trim());
      }
      return res.json();
    }

    function safeInitial(name){
      const s = String(name || "").trim();
      if(!s) return "N";
      const first = s.replace(/^https?:\/\//, "").trim().charAt(0);
      return (first || "N").toUpperCase();
    }

    function decodeJsonString(value){
      if(!value) return value;
      try{
        const escaped = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        return JSON.parse(`"${escaped}"`);
      }catch{
        return value;
      }
    }

    // =========================
    // NEW: YouTube LIVE detection (HTML via /proxy)
    // =========================
    function decodeHtmlEntities(str){
      if(!str) return "";
      const el = document.createElement("textarea");
      el.innerHTML = str;
      return el.value;
    }

    function getMetaContent(html, prop){
      const re = new RegExp(`<meta\\s+property="${prop}"\\s+content="([^"]+)"`, "i");
      return decodeHtmlEntities(html.match(re)?.[1] || "");
    }

    function getCanonicalHref(html){
      const m = html.match(/<link\\s+rel="canonical"\\s+href="([^"]+)"/i);
      return decodeHtmlEntities(m?.[1] || "");
    }

    async function fetchYouTubeLiveNow(channelId, channelName){
      // YouTube routes /live to the active broadcast if live
      const liveLanding = `https://www.youtube.com/channel/${channelId}/live`;
      const html = await fetchTextViaProxy(liveLanding);

      const isLive =
        /"isLiveContent"\s*:\s*true/.test(html) ||
        /"isLive"\s*:\s*true/.test(html);

      if(!isLive) return null;

      const url = getMetaContent(html, "og:url") || getCanonicalHref(html);
      if(!url || !/youtube\.com\/watch\?v=/.test(url)) return null;

      const title = getMetaContent(html, "og:title") || "Live stream";
      const ogImage = getMetaContent(html, "og:image");

      return buildLiveModel({
        title,
        channel: channelName || "Unknown channel",
        url,
        // proxy the image so it always loads on your site
        thumbnail: ogImage ? workerProxyUrl(ogImage) : "",
        platform: "YouTube",
      });
    }

    function dedupeByUrl(list){
      const seen = new Set();
      return list.filter(item => {
        const u = item?.url;
        if(!u) return false;
        if(seen.has(u)) return false;
        seen.add(u);
        return true;
      });
    }

    // === FEED (VIDEOS) ===
    function parseFeed(xmlText){
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, "application/xml");

      const authorName = doc.getElementsByTagName("author")[0]
        ?.getElementsByTagName("name")[0]
        ?.textContent?.trim() || null;

      const entries = Array.from(doc.getElementsByTagName("entry"));
      const items = entries.map(entry => {
        const id = entry.getElementsByTagName("yt:videoId")[0]?.textContent?.trim();
        const title = entry.getElementsByTagName("title")[0]?.textContent?.trim();
        const published = entry.getElementsByTagName("published")[0]?.textContent?.trim();
        const channel = entry.getElementsByTagName("name")[0]?.textContent?.trim();
        const thumbnail = entry.getElementsByTagName("media:thumbnail")[0]?.getAttribute("url");

        const liveStatus = entry.getElementsByTagName("yt:liveBroadcastContent")[0]?.textContent?.trim() || null;

        const viewsAttr = entry.getElementsByTagName("media:statistics")[0]?.getAttribute("views");
        const views = viewsAttr ? Number(viewsAttr) : null;

        return {
          id,
          title,
          channel,
          publishedAt: published ? new Date(published) : null,
          thumbnail,
          views: Number.isFinite(views) ? views : null,
          liveStatus,
        };
      }).filter(v => v.id);

      return { authorName, items };
    }

    async function fetchChannelFeed(channelId){
      try{
        const feedUrl = `https://www.youtube.com/feeds/videos.xml?channel_id=${channelId}`;
        const xmlText = await fetchTextViaProxy(feedUrl);
        return parseFeed(xmlText);
      }catch(error){
        console.warn("Channel feed fetch failed.", channelId, error);
        return { authorName: null, items: [] };
      }
    }

    function buildVideoModel(item){
      const videoId = item?.id;
      if(!videoId) return null;
      return {
        id: videoId,
        title: item.title || "Untitled video",
        channel: item.channelName || item.channel || "Unknown channel",
        channelUrl: item.channelUrl || "",
        channelAvatar: item.channelAvatar || "",
        publishedAt: item.publishedAt || null,
        thumbnail: item.thumbnail || "",
        url: `https://www.youtube.com/watch?v=${videoId}`,
        views: Number.isFinite(item.views) ? item.views : null,
      };
    }

    function buildLiveModel(item){
      if(!item?.url) return null;
      return {
        title: item.title || "Live stream",
        channel: item.channel || "Unknown channel",
        url: item.url,
        thumbnail: item.thumbnail || "",
        platform: item.platform || "YouTube",
      };
    }

    function formatCompactNumber(value){
      const count = Number(value);
      if(!Number.isFinite(count)) return "—";
      if(count < 1000) return Math.round(count).toString();
      if(count < 100000){
        const rounded = Math.round((count / 1000) * 10) / 10;
        return `${rounded % 1 === 0 ? rounded.toFixed(0) : rounded.toFixed(1)}K`;
      }
      if(count < 1000000){
        return `${Math.round(count / 1000)}K`;
      }
      const rounded = Math.round((count / 1000000) * 10) / 10;
      return `${rounded % 1 === 0 ? rounded.toFixed(0) : rounded.toFixed(1)}M`;
    }

    function formatViewCount(value){
      return formatCompactNumber(value);
    }

    const relativeFormatter = new Intl.RelativeTimeFormat("en", { numeric: "auto" });

    function formatRelativeDate(date){
      if(!date) return "—";
      const diffMs = Date.now() - date.getTime();
      if(!Number.isFinite(diffMs)) return "—";
      const diffSeconds = Math.round(diffMs / 1000);
      const absSeconds = Math.abs(diffSeconds);
      if(absSeconds < 60) return "just now";
      const diffMinutes = Math.round(diffSeconds / 60);
      if(Math.abs(diffMinutes) < 60) return relativeFormatter.format(-diffMinutes, "minute");
      const diffHours = Math.round(diffMinutes / 60);
      if(Math.abs(diffHours) < 24) return relativeFormatter.format(-diffHours, "hour");
      const diffDays = Math.round(diffHours / 24);
      if(Math.abs(diffDays) < 7) return relativeFormatter.format(-diffDays, "day");
      if(Math.abs(diffDays) < 30) return relativeFormatter.format(-Math.round(diffDays / 7), "week");
      if(Math.abs(diffDays) < 365) return relativeFormatter.format(-Math.round(diffDays / 30), "month");
      return relativeFormatter.format(-Math.round(diffDays / 365), "year");
    }

    function setPaginationVisibility(isVisible){
      paginationTopEl.hidden = !isVisible;
      paginationBottomEl.hidden = !isVisible;
    }

    function setActiveLeagueTab(targetId){
      for(const section of leagueSections){
        const isActive = section.id === targetId;
        section.hidden = !isActive;
        section.setAttribute("aria-hidden", isActive ? "false" : "true");
      }
      for(const tab of leagueTabs){
        const isActive = tab.dataset.target === targetId;
        tab.classList.toggle("is-active", isActive);
        tab.setAttribute("aria-selected", isActive ? "true" : "false");
      }
    }

    function initLeagueTabs(){
      if(!leagueTabs.length) return;
      const targetIds = new Set(leagueSections.map(section => section.id));
      const initial = leagueTabs.find(tab => tab.classList.contains("is-active") && targetIds.has(tab.dataset.target))
        || leagueTabs.find(tab => targetIds.has(tab.dataset.target))
        || null;

      if(initial?.dataset.target){
        setActiveLeagueTab(initial.dataset.target);
      }

      for(const tab of leagueTabs){
        if(!targetIds.has(tab.dataset.target)) continue;
        tab.addEventListener("click", (event) => {
          event.preventDefault();
          setActiveLeagueTab(tab.dataset.target);
        });
      }
    }

    function buildPaginationButton(label, options = {}){
      const button = document.createElement("button");
      button.type = "button";
      button.className = "pagination-button";
      button.textContent = label;
      if(options.disabled) button.disabled = true;
      if(options.active) button.classList.add("is-active");
      if(options.label) button.setAttribute("aria-label", options.label);
      if(options.onClick) button.addEventListener("click", options.onClick);
      return button;
    }

    function renderPaginationControls(totalPages){
      const renderTo = (container) => {
        container.innerHTML = "";
        if(totalPages <= 1){
          return;
        }

        const prevButton = buildPaginationButton("←", {
          disabled: STATE.currentPage === 1,
          label: "Previous page",
          onClick: () => {
            STATE.currentPage = Math.max(1, STATE.currentPage - 1);
            renderFromState();
          },
        });

        container.appendChild(prevButton);

        for(let page = 1; page <= totalPages; page += 1){
          const pageButton = buildPaginationButton(String(page), {
            active: page === STATE.currentPage,
            label: `Page ${page}`,
            onClick: () => {
              STATE.currentPage = page;
              renderFromState();
            },
          });
          container.appendChild(pageButton);
        }

        const nextButton = buildPaginationButton("→", {
          disabled: STATE.currentPage === totalPages,
          label: "Next page",
          onClick: () => {
            STATE.currentPage = Math.min(totalPages, STATE.currentPage + 1);
            renderFromState();
          },
        });

        container.appendChild(nextButton);
      };

      renderTo(paginationTopEl);
      renderTo(paginationBottomEl);
    }

    function renderVideos(list){
      gridEl.innerHTML = "";
      if(!list.length){
        statusEl.textContent = "No videos were found in the last 90 days.";
        setPaginationVisibility(false);
        return;
      }
      statusEl.textContent = `${list.length} video${list.length === 1 ? "" : "s"}`;

      const totalPages = Math.max(1, Math.ceil(list.length / STATE.pageSize));
      if(STATE.currentPage > totalPages) STATE.currentPage = totalPages;
      if(STATE.currentPage < 1) STATE.currentPage = 1;

      const startIndex = (STATE.currentPage - 1) * STATE.pageSize;
      const pagedList = list.slice(startIndex, startIndex + STATE.pageSize);

      setPaginationVisibility(totalPages > 1);
      renderPaginationControls(totalPages);

      const frag = document.createDocumentFragment();
      for(const video of pagedList){
        const card = document.createElement("article");
        card.className = "video-card";

        const link = document.createElement("a");
        link.href = video.url;
        link.target = "_blank";
        link.rel = "noopener noreferrer";

        const img = document.createElement("img");
        img.className = "video-thumb";
        img.src = video.thumbnail || "";
        img.alt = video.title || "Video thumbnail";
        img.loading = "lazy";

        link.appendChild(img);

        const titleLink = document.createElement("a");
        titleLink.className = "video-title";
        titleLink.textContent = video.title;
        titleLink.href = video.url;
        titleLink.target = "_blank";
        titleLink.rel = "noopener noreferrer";

        const meta = document.createElement("div");
        meta.className = "video-meta";

        const channelLine = document.createElement("div");
        channelLine.className = "video-meta-line";

        const channelWrap = document.createElement("div");
        channelWrap.className = "video-channel";

        if(video.channelAvatar){
          const avatar = document.createElement("img");
          avatar.className = "video-channel-avatar";
          avatar.src = video.channelAvatar;
          avatar.alt = `${video.channel} avatar`;
          avatar.loading = "lazy";
          channelWrap.appendChild(avatar);
        }else{
          const avatarFallback = document.createElement("div");
          avatarFallback.className = "video-channel-avatar video-channel-avatar-placeholder";
          avatarFallback.textContent = safeInitial(video.channel);
          channelWrap.appendChild(avatarFallback);
        }

        const channelLink = document.createElement("a");
        channelLink.className = "video-channel-name";
        channelLink.textContent = video.channel;
        channelLink.href = video.channelUrl || "#";
        channelLink.target = "_blank";
        channelLink.rel = "noopener noreferrer";

        channelWrap.appendChild(channelLink);
        channelLine.appendChild(channelWrap);

        const metaLine = document.createElement("div");
        metaLine.className = "video-meta-line";

        const published = document.createElement("span");
        published.className = "video-meta-muted";
        published.textContent = formatRelativeDate(video.publishedAt);

        const hasViews = Number.isFinite(video.views);
        if(hasViews){
          const views = document.createElement("span");
          views.className = "video-meta-muted";
          views.textContent = `${formatViewCount(video.views)} views`;

          const sep = document.createElement("span");
          sep.className = "video-meta-sep";
          sep.textContent = "•";

          metaLine.append(views, sep, published);
        }else{
          metaLine.append(published);
        }

        meta.append(channelLine, metaLine);
        card.append(link, titleLink, meta);
        frag.appendChild(card);
      }
      gridEl.appendChild(frag);
    }

    function renderLiveNow(list){
      liveGridEl.innerHTML = "";
      if(!list.length){
        liveStatusEl.textContent = "";
        liveSectionEl.hidden = true;
        return;
      }

      liveSectionEl.hidden = false;
      liveStatusEl.textContent = `${list.length} live now`;
      const frag = document.createDocumentFragment();

      for(const stream of list){
        const card = document.createElement("article");
        card.className = "live-card";

        const link = document.createElement("a");
        link.href = stream.url;
        link.target = "_blank";
        link.rel = "noopener noreferrer";

        const img = document.createElement("img");
        img.className = "live-thumb";
        img.src = stream.thumbnail || "";
        img.alt = stream.title || "Live stream thumbnail";
        img.loading = "lazy";

        link.appendChild(img);

        const titleLink = document.createElement("a");
        titleLink.className = "live-title";
        titleLink.textContent = stream.title;
        titleLink.href = stream.url;
        titleLink.target = "_blank";
        titleLink.rel = "noopener noreferrer";

        const meta = document.createElement("div");
        meta.className = "live-meta";

        const liveBadge = document.createElement("span");
        liveBadge.className = "live-badge";
        liveBadge.textContent = "LIVE";

        const platform = document.createElement("span");
        platform.className = "live-platform";
        platform.textContent = stream.platform;

        const channel = document.createElement("span");
        channel.textContent = stream.channel;

        meta.append(liveBadge, platform, channel);
        card.append(link, titleLink, meta);
        frag.appendChild(card);
      }

      liveGridEl.appendChild(frag);
    }

    function formatSubscribers(value){
      const formatted = formatCompactNumber(value);
      return `${formatted} subscribers`;
    }

    function renderChannels(list){
      gridEl.innerHTML = "";
      if(!list.length){
        statusEl.textContent = "No channels were found.";
        setPaginationVisibility(false);
        return;
      }
      statusEl.textContent = `Showing ${list.length} channel${list.length === 1 ? "" : "s"}.`;
      setPaginationVisibility(false);

      const frag = document.createDocumentFragment();
      for(const channel of list){
        const card = document.createElement("article");
        card.className = "channel-card";

        const bannerLink = document.createElement("a");
        bannerLink.href = channel.url;
        bannerLink.target = "_blank";
        bannerLink.rel = "noopener noreferrer";
        bannerLink.className = "channel-banner";

        if(channel.banner){
          const banner = document.createElement("img");
          banner.src = channel.banner;
          banner.alt = `${channel.name || "Channel"} banner`;
          banner.loading = "lazy";
          bannerLink.appendChild(banner);
        }

        const avatarWrap = document.createElement("div");
        avatarWrap.className = "channel-avatar-wrap";

        if(channel.avatar){
          const avatar = document.createElement("img");
          avatar.className = "channel-avatar";
          avatar.src = channel.avatar;
          avatar.alt = "Channel avatar";
          avatar.loading = "lazy";
          avatarWrap.appendChild(avatar);
        }else{
          const ph = document.createElement("div");
          ph.className = "channel-avatar-placeholder";
          ph.textContent = safeInitial(channel.name);
          avatarWrap.appendChild(ph);
        }

        bannerLink.appendChild(avatarWrap);

        const name = document.createElement("p");
        name.className = "channel-name";
        name.textContent = channel.name || channel.url;

        const meta = document.createElement("div");
        meta.className = "channel-meta";

        const subscribers = document.createElement("span");
        subscribers.textContent = formatSubscribers(channel.subscribers);

        meta.append(subscribers);

        const body = document.createElement("div");
        body.className = "channel-body";
        body.append(name, meta);

        card.append(bannerLink, body);
        frag.appendChild(card);
      }
      gridEl.appendChild(frag);
    }

    function sortVideos(list, mode){
      const sorted = [...list];
      if(mode === "views"){
        sorted.sort((a, b) => (Number(b.views) || 0) - (Number(a.views) || 0));
      }else{
        sorted.sort((a, b) => (b.publishedAt?.getTime() || 0) - (a.publishedAt?.getTime() || 0));
      }
      return sorted;
    }

    function sortChannels(list){
      return [...list].sort((a, b) => (Number(b.subscribers) || 0) - (Number(a.subscribers) || 0));
    }

    async function runWithConcurrency(items, limit, worker){
      const results = new Array(items.length);
      let idx = 0;

      async function runner(){
        while(true){
          const current = idx++;
          if(current >= items.length) return;
          results[current] = await worker(items[current], current);
        }
      }

      const runners = Array.from({ length: Math.max(1, Math.min(limit, items.length)) }, () => runner());
      await Promise.all(runners);
      return results;
    }

    function normalizeTwitchThumbnail(url){
      if(!url) return "";
      return url.replace("{width}", "640").replace("{height}", "360");
    }

    async function fetchTwitchLiveData(entry){
      try{
        const html = await fetchTextViaProxy(entry.url);
        const isLive = /"isLiveBroadcast":true/.test(html) || /"isLive":true/.test(html);
        if(!isLive) return null;

        const doc = new DOMParser().parseFromString(html, "text/html");
        const ogTitle = doc.querySelector('meta[property="og:title"]')?.content?.trim();
        const ogImage = doc.querySelector('meta[property="og:image"]')?.content?.trim();
        const description = doc.querySelector('meta[property="og:description"]')?.content?.trim();

        const displayMatch = html.match(/"channelDisplayName":"([^"]+)"/);
        const displayName = decodeJsonString(displayMatch?.[1]) || entry.channel;

        const titleMatch = html.match(/"broadcastSettings":\{"title":"([^"]+)"/);
        const streamTitle = decodeJsonString(titleMatch?.[1]) || description || ogTitle || "Live stream";

        return buildLiveModel({
          title: streamTitle,
          channel: displayName,
          url: entry.url,
          thumbnail: normalizeTwitchThumbnail(ogImage),
          platform: "Twitch",
        });
      }catch(error){
        console.warn("Twitch live check failed.", entry.url, error);
        return null;
      }
    }

    function renderFromState(){
      const mode = sortEl.value;

      if(mode === "channels"){
        STATE.currentPage = 1;
        renderChannels(sortChannels(STATE.channels));
        return;
      }

      renderVideos(sortVideos(STATE.videos, mode));
    }

    async function checkProxyHealth(){
      try{
        const text = await fetchTextViaProxy("https://www.youtube.com/robots.txt");
        return Boolean(text && text.includes("User-agent"));
      }catch(e){
        return false;
      }
    }

    async function loadData(){
      STATE.errors = [];
      gridEl.innerHTML = "";
      liveGridEl.innerHTML = "";
      liveSectionEl.hidden = true;

      const proxyOk = await checkProxyHealth();
      if(!proxyOk){
        statusEl.textContent =
          "YouTube proxy check failed.\n" +
          "Your Worker likely does NOT implement GET /proxy?url=...\n" +
          "Fix that first or YouTube feeds & oEmbed will never load.";
        liveStatusEl.textContent = "Live status unavailable while the proxy is offline.";
        liveSectionEl.hidden = false;
        return;
      }

      try{
        statusEl.textContent = "";
        liveStatusEl.textContent = "";

        const values = await fetchRange("A:B");
        const youtubeRows = values.map(row => row?.[0]).filter(Boolean);
        const twitchRows = values.map(row => row?.[1]).filter(Boolean);

        const youtubeSheetEntries = youtubeRows
          .map(entry => String(entry).trim())
          .filter(Boolean)
          .filter((entry, index) => !(index === 0 && entry.toLowerCase() === "channels"));

        const twitchSheetEntries = twitchRows
          .map(entry => String(entry).trim())
          .filter(entry => entry && entry.toLowerCase() !== "twitch" && entry.toLowerCase() !== "channel")
          .map(entry => {
            if(/^https?:\/\//i.test(entry) || entry.toLowerCase().startsWith("twitch:")) return entry;
            return `twitch:${entry}`;
          });

        const entries = [...youtubeSheetEntries, ...twitchSheetEntries];

        if(!entries.length){
          statusEl.textContent = "No channels found in the sheet.";
          liveStatusEl.textContent = "No channels found in the sheet.";
          liveSectionEl.hidden = false;
          return;
        }

        const parsedEntries = entries.map(parseChannelEntry).filter(Boolean);
        if(!parsedEntries.length){
          statusEl.textContent = "No valid YouTube URLs or channel IDs were found.";
          liveStatusEl.textContent = "No valid YouTube or Twitch channels were found.";
          liveSectionEl.hidden = false;
          return;
        }

        const youtubeEntries = parsedEntries.filter(entry => entry.platform === "youtube");
        const twitchEntries = parsedEntries.filter(entry => entry.platform === "twitch");

        const { start, end } = getRolling90DaysWindow();
        const videos = [];
        const liveNow = [];

        const channels = await runWithConcurrency(youtubeEntries, 4, async (entry) => {
          const channelUrl = entry.url;

          const id = entry.id || await resolveChannelId(channelUrl);

          let name = null;
          let avatar = "";
          let subscribers = null;
          let banner = "";
          if(id){
            try{
              const meta = await fetchChannelMetadata(id);
              name = meta?.title || null;
              avatar = meta?.avatar || "";
              banner = meta?.banner || "";
              subscribers = Number.isFinite(meta?.subscribers) ? meta.subscribers : null;
            }catch(e){
              console.warn("Channel metadata failed", id, e);
            }
          }

          try{
            if(!name || !avatar){
              const o = await fetchChannelOEmbed(channelUrl);
              name = name || o?.title || o?.author_name || null;
              avatar = avatar || o?.thumbnail_url || "";
            }
          }catch(e){
            console.warn("oEmbed failed", channelUrl, e);
          }

          // ✅ NEW: YouTube LIVE detection via /channel/UC.../live
          if(id){
            try{
              const live = await fetchYouTubeLiveNow(id, name);
              if(live) liveNow.push(live);
            }catch(e){
              console.warn("YouTube live check failed", id, e);
            }
          }

          let previewCount = 0;
          let latest = null;

          if(id){
            const feed = await fetchChannelFeed(id);
            previewCount = feed.items.length;
            latest = feed.items
              .map(v => v.publishedAt)
              .filter(Boolean)
              .sort((a, b) => b - a)[0] || null;

            if(!name && feed.authorName) name = feed.authorName;

            for(const item of feed.items){
              const model = buildVideoModel({
                ...item,
                channelName: name,
                channelUrl,
                channelAvatar: avatar,
              });
              if(!model?.publishedAt) continue;

              if(model.publishedAt >= start && model.publishedAt <= end){
                videos.push(model);
              }

              // Keep RSS liveStatus path too, but it's unreliable
              if(item.liveStatus === "live"){
                const liveModel = buildLiveModel({
                  title: item.title,
                  channel: name,
                  url: model.url,
                  thumbnail: item.thumbnail,
                  platform: "YouTube",
                });
                if(liveModel) liveNow.push(liveModel);
              }
            }
          }else{
            console.warn("No channel ID resolved for", channelUrl);
          }

          if(!name){
            try{
              const u = new URL(channelUrl);
              name = u.pathname.startsWith("/@")
                ? u.pathname.replace("/@", "@")
                : (u.pathname.split("/").filter(Boolean).slice(-1)[0] || channelUrl);
            }catch{
              name = channelUrl;
            }
          }

          return {
            url: channelUrl,
            id,
            name,
            avatar,
            banner,
            subscribers,
            previewCount,
            latest,
          };
        });

        const twitchLive = await runWithConcurrency(twitchEntries, 4, fetchTwitchLiveData);
        for(const item of twitchLive){
          if(item) liveNow.push(item);
        }

        // ✅ Merge real YouTube views via /yt/videos
        try{
          const statsMap = await fetchVideoStats(videos.map(v => v.id));
          for(const v of videos){
            const statsItem = statsMap.get(v.id);
            const viewCount = statsItem?.statistics?.viewCount;
            if(viewCount != null) v.views = Number(viewCount);
          }
          STATE.viewsReady = true;
        }catch(e){
          console.warn("Video stats merge failed", e);
          STATE.viewsReady = false;
        }

        STATE.channels = channels;
        STATE.videos = videos;
        STATE.liveNow = dedupeByUrl(liveNow);

        renderLiveNow(STATE.liveNow);
        renderFromState();
      }catch(error){
        statusEl.textContent = `Unable to load: ${error?.message || "Unknown error"}`;
        liveStatusEl.textContent = "Unable to load live status right now.";
        console.error(error);
      }
    }

    sortEl.addEventListener("change", () => {
      STATE.currentPage = 1;
      renderFromState();
    });

    document.addEventListener("visibilitychange", () => {
      if(document.visibilityState === "visible"){
        loadData();
      }
    });

    initLeagueTabs();
    loadData();
  </script>
</body>
</html>
